Stage 1/4: A window to editing

Description
When writing a code, you use a text editor. However did you know you can do a lot more with a text editor than just programming? You can make notes in the text files and save important or temporary information. In this project, you will write a functional text editor that allows you to do just that. We will use Swing to create a graphical user interface (GUI).

In Swing, the class that represents an empty window is JFrame. Actually, all of the classes that represent graphic elements in Swing start with the letter 'J.' Don't confuse these classes with classes that represent graphic elements of the AWT library (for example, the Button class in the AWT library versus the JButton class in the Swing library).

To improve the basic window, you should extend this class and write your own logic for the window. Let's see this code below in the constructor of TextEditor class that extends JFrame:

setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
setSize(300, 300);
setVisible(true); 
setLayout(null);
Without the first line, if you close the program, your program would still be running, and after that, you can only kill it using the task manager or the IDE (if you are running it under an IDE).

The second line sets the size of the window. Without it, the program would be 0 pixels in width and height. Of course, nothing can fit in this window size. And if you run the program, you would see nothing because the window is invisible by default. The third line fixes this. The fourth line means that there won't be any strategy for placing the elements on the screen. We will discuss different layouts later. For now, you can place components on the window using absolute coordinates and bounds.

You can place any component anywhere using component.setLocation(int x , int y) and component.setSize(int width, int height). If you want to change both the size and the location of the component, you may want to use component.setBounds(int x, int y, int width, int height). To add a Swing component to the window, you need to invoke the add method and pass the component as a parameter. For example: add(component).

Also, you can use the setTitle method to set the name of the window.

You can find the list of components here and here. In this stage, you need to write the most suitable component for our needs; JTextArea. For now, you can only edit text in the program, not save it or load it to the hard drive.

For the testing reasons, you need to set the name of each component using the component.setName(String name) method.
For now, there is only one component JTextArea and you should name it "TextArea."

Stage 2/4: Saved and loaded

Description
In this stage, you will write a program that can read files from the hard drive, edit them, and save them to the same or any other file.

Notice that if you expand the window, the other elements stay in the same place. However, in most applications, you can see that some components get bigger or smaller when you change the size of the window. To do this, you should apply another layout instead of the null layout that was shown in the first stage.

In Java, there are a lot of different layouts, and the default layout is named BorderLayout. This layout has 5 places for components: top, bottom, left, right, and center. If you execute the code below you can see where these places are. Do not forget to remove the setLayout(null) line and add nothing, as BorderLayout is a standard layout for JFrame. Here you can see a visual representation of different layouts.

add(new JButton("North"), BorderLayout.NORTH);
add(new JButton("South"), BorderLayout.SOUTH);
add(new JButton("West"), BorderLayout.WEST);
add(new JButton("East"), BorderLayout.EAST);
add(new JButton("Center"), BorderLayout.CENTER);
So this layout can contain only 5 components, but is this enough to create more complex programs? Yes, and actually this layout is used widely when developing programs on Swing. The component JPanel can contain other components. The default layout for this is FlowLayout; it puts components on the screen from left to right and from top to bottom. Just add a JPanel component to the frame with BorderLayout and then add several components to this JPanel with FlowLayout! You can find out more about BorderLayout here and here. Check out this link to see how to use FlowLayout.

Did you notice that if you type more text than the size of the component (in our case, in JTextArea), then the text is just not visible? This is the problem that can happen with any component. To solve it, this component should be wrapped by another component - JScrollPane. This class takes the initial component as a parameter and should be added to the JFrame instead of it. Also, all manipulations with size and location should be done with this wrapper. As a result, the component can be scrolled horizontally as well as vertically. Here and here you can see how to use JScrollPane.

Now, let's add working with files. To load a file from a hard drive, the user should specify the name of the existing file. If you run this from an IDE, this file should be in the same folder as the "src" folder. Then, after the user presses the "Load" button, the content of the file should be displayed in the text field. After editing, you should be able to save the file. For that you need to specify a name for the file and then press the button "Save".

To create a one-line input field for the name of the file you need the JTextField component. To get the input text from that field, you need the getText method.

To create buttons, you need JButton. Now, you need to add interaction with buttons. Some of the code should execute when pressing the button. To perform this action, you need ActionListener. Since ActionListener is an interface, you need to implement the actionPerformed method in a class that implements this interface. This would be your code when the user presses the button. Note, that for different buttons you need different logic, so you need different classes that implement the ActionListener interface. After that, you need to bind each class with each button. The method button.addActionListener(ActionListener listener) makes this possible. This method takes an object of a class that implements ActionListener. After that, everything should be fine. Pressing the button triggers the actionPerformed method of that object.

If you are familiar with lambdas, you can use them instead of creating classes that will be used only once. You can implement them as shown in the following template:

JButton button = new JButton();
button.addActionListener(actionEvent -> {
/* write your code here */
});
During the programming of this stage, you may want to slightly tweak the sizes of the components. You can do it in two ways: first is to create an invisible border around it (this link will help), and the second is to force the component to be a certain size (this link).

Due to testing reasons, you need to set names to some components.

Set the names to these components:

JTextArea component to "TextArea"
A field which contains filename to "FilenameField"
A button that saves the file to "SaveButton"
A button that loads a file to "LoadButton"
ScrollPane to "ScrollPane"

Stage 3/4: Menu, please!

Description
In this stage, you will improve your text editor.

Also, in this stage, you should implement a menu bar. It is the GUI element that sits in the top left corner of the screen and pops up with different options when you click on it. This should be implemented using JMenuBar, whose menu lists are implemented using JMenu and whose menu items are implemented using JMenuItem. You should add an ActionListener to every JMenuItem in the menu bar. The menu bar should contain three options: Load, Save and Exit, which duplicate the buttons Load, Save, and the "Exit" option which should shut down the application. To safely close the window, you should call a method dispose() on the JFrame. You may look at this tutorial to create a menu bar.

Due to testing reasons, you need to set name to some components.

Set the names to these components:

JTextArea component to "TextArea"
Field which contains filename to "FilenameField"
Button that saves the file to "SaveButton"
Button that loads a file to "LoadButton"
ScrollPane to "ScrollPane"
JMenu "File" to "MenuFile"
JMenuItem "Load" option in menu to "MenuLoad"
JMenuItem "Save" option in menu to "MenuSave"
JMenuItem "Exit" option in menu to "MenuExit"

Stage 4/4: Searching

Description
In this stage, you will improve the usability of your text editor.

The first thing to point out is that the "Save" and "Load" buttons take up a lot of space on the screen. You can't add a lot of buttons to the top bar when they contain text. This problem can be solved using icons instead of text. The constructor of JButton can take an ImageIcon instead of text. You should replace the buttons "Load" and "Save" with corresponding icons. You can download the icons from the internet.

It is also impractical to restrict users to load (open) a file from only one directory, i.e. the project folder. The Swing library has a useful component for navigating your filesystem called JFileChooser. So, when the user clicks on the "Open" button (the button that was previously named "Load") you should open a file manager using JFileChooser and let the user choose the file he wants to open. Then, the contents of this file should be visible in the text editor. You follow this link to see how to use JFileChooser.

Also, you should add a search panel. It should contain a text field, a "Start search" button, a "Previous match" button and a "Next match‚Äù button. All of these buttons should also be icons. The search can be performed by regular expressions or by plain text. For this, you should add a checkbox that is checked when the user wants to search using a regular expression. You can use JCheckBox for this. The search can slow down the GUI thread, so you should implement the search in a separate thread.

After the user presses the "Start search" button, the program should select the first part of the text that is matched and put the caret at the end of the selected part. Use buttons "Next match" and "Previous match" to iterate through all the matches in the text. You can use the following working code to set the caret position and select the text of the text area:

textArea.setCaretPosition(index + foundText.length());
textArea.select(index, index + foundText.length());
textArea.grabFocus();
Do not forget about the menu. You can add a new menu list with search functionality that copies all the search buttons.

Due to testing reasons, you need to name some components.

Set the names to these components:

JTextArea component to "TextArea"
Search field to "SearchField"
Button that saves the file to "SaveButton"
Button that opens a filemanager to "OpenButton"
Start search button to "StartSearchButton"
Previous match button to "PreviousMatchButton"
Next match button to "NextMatchButton"
Use regex checkbox to "UseRegExCheckbox"
JFileChooser to "FileChooser"
ScrollPane to "ScrollPane"
File option in menu to "MenuFile"
Search option in menu to "MenuSearch"
Open option in menu to "MenuOpen"
Save option in menu to "MenuSave"
Exit option in menu to "MenuExit"
Start search option in menu to "MenuStartSearch"
Previous match option in menu to "MenuPreviousMatch"
Next match option in menu to "MenuNextMatch"
Use regex option in menu to "MenuUseRegExp"
For the testing reasons, you should use a single instance of JFileChooser. Add this instance to the frame using add method. Hide this instance of JFileChooser if it isn't needed at the moment and show it when it is.
